// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;
import 'package:ffi/ffi.dart' as pkg_ffi;

/// Bindings for the Torch C++ API
class TorchCppBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  TorchCppBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  TorchCppBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  double init_OnnxModel() {
    return _init_OnnxModel();
  }

  late final _init_OnnxModelPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function()>>('init_OnnxModel');
  late final _init_OnnxModel =
      _init_OnnxModelPtr.asFunction<double Function()>();

  ffi.Pointer<pkg_ffi.Utf8> do_Json() {
    return _do_Json();
  }

  late final _do_JsonPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<pkg_ffi.Utf8> Function()>>(
          'do_Json');
  late final _do_Json =
      _do_JsonPtr.asFunction<ffi.Pointer<pkg_ffi.Utf8> Function()>();

  double do_MatrixOps(
    double x,
  ) {
    return _do_MatrixOps(
      x,
    );
  }

  late final _do_MatrixOpsPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>(
          'do_MatrixOps');
  late final _do_MatrixOps =
      _do_MatrixOpsPtr.asFunction<double Function(double)>();

  void create_Stack() {
    return _create_Stack();
  }

  late final _create_StackPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('create_Stack');
  late final _create_Stack = _create_StackPtr.asFunction<void Function()>();

  void push_Stack(
    int x,
  ) {
    return _push_Stack(
      x,
    );
  }

  late final _push_StackPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int32)>>('push_Stack');
  late final _push_Stack = _push_StackPtr.asFunction<void Function(int)>();

  int pop_Stack() {
    return _pop_Stack();
  }

  late final _pop_StackPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('pop_Stack');
  late final _pop_Stack = _pop_StackPtr.asFunction<int Function()>();

  void delete_Stack() {
    return _delete_Stack();
  }

  late final _delete_StackPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('delete_Stack');
  late final _delete_Stack = _delete_StackPtr.asFunction<void Function()>();

  bool isEmpty_Stack() {
    return _isEmpty_Stack();
  }

  late final _isEmpty_StackPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>('isEmpty_Stack');
  late final _isEmpty_Stack = _isEmpty_StackPtr.asFunction<bool Function()>();

  int len_Stack() {
    return _len_Stack();
  }

  late final _len_StackPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('len_Stack');
  late final _len_Stack = _len_StackPtr.asFunction<int Function()>();

  int do_Stack(
    int a,
    int b,
  ) {
    return _do_Stack(
      a,
      b,
    );
  }

  late final _do_StackPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32, ffi.Int32)>>(
          'do_Stack');
  late final _do_Stack = _do_StackPtr.asFunction<int Function(int, int)>();

  ffi.Pointer<pkg_ffi.Utf8> add_Str(
    ffi.Pointer<pkg_ffi.Utf8> x,
  ) {
    return _add_Str(
      x,
    );
  }

  late final _add_StrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pkg_ffi.Utf8> Function(
              ffi.Pointer<pkg_ffi.Utf8>)>>('add_Str');
  late final _add_Str = _add_StrPtr.asFunction<
      ffi.Pointer<pkg_ffi.Utf8> Function(ffi.Pointer<pkg_ffi.Utf8>)>();

  ffi.Pointer<ffi.Int32> add_Array1D(
    int size,
  ) {
    return _add_Array1D(
      size,
    );
  }

  late final _add_Array1DPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Int32> Function(ffi.Int32)>>(
          'add_Array1D');
  late final _add_Array1D =
      _add_Array1DPtr.asFunction<ffi.Pointer<ffi.Int32> Function(int)>();

  ffi.Pointer<ffi.Pointer<ffi.Int32>> add_Array2D(
    int rows,
    int columns,
  ) {
    return _add_Array2D(
      rows,
      columns,
    );
  }

  late final _add_Array2DPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Pointer<ffi.Int32>> Function(
              ffi.Int32, ffi.Int32)>>('add_Array2D');
  late final _add_Array2D = _add_Array2DPtr
      .asFunction<ffi.Pointer<ffi.Pointer<ffi.Int32>> Function(int, int)>();

  int count_Array1D(
    ffi.Pointer<ffi.Int32> array,
    int rows,
  ) {
    return _count_Array1D(
      array,
      rows,
    );
  }

  late final _count_Array1DPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Int32>, ffi.Int32)>>('count_Array1D');
  late final _count_Array1D =
      _count_Array1DPtr.asFunction<int Function(ffi.Pointer<ffi.Int32>, int)>();

  int count_Array2D(
    ffi.Pointer<ffi.Pointer<ffi.Int32>> array,
    int rows,
    int columns,
  ) {
    return _count_Array2D(
      array,
      rows,
      columns,
    );
  }

  late final _count_Array2DPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<ffi.Pointer<ffi.Int32>>, ffi.Int32,
              ffi.Int32)>>('count_Array2D');
  late final _count_Array2D = _count_Array2DPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Int32>>, int, int)>();
}

const int __bool_true_false_are_defined = 1;

const int true1 = 1;

const int false1 = 0;
